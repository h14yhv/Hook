E:\Auto\TranslateTool\Translate\Translate\test\Dest_eng.txtious kernel1 code, you need to understand how kernel1 code1 works, why malware writers use it, and some of the unique challenges it presents. Windows device1 drivers, more commonly referred to simply as drivers, allow third-party developers to run code1 in the Windows kernel1 .
Drivers are difficult to analyze because they load into memory, stay resident, and respond to requests from applications. This is further complicated because applications do not directly interact with kernel1 drivers. Instead, they access device1 objects, which send requests to particular devices. Devices are not necessarily physical hardware components; the driver1 creates and destroys devices, which can be accessed from user space .
For example, consider a USB flash drive. A driver1 on the system handles USB flash drives, but an application does not make requests directly to that driver; it makes requests to a specific device1 object1 instead. When the user plugs the USB flash drive into the computer, Windows creates the “F: drive” device1 object1 for that drive. An application can now make requests to the F:drive, which ultimately will be sent to the driver1 for USB flash drives. The same driver1 might handle1 requests for a second USB flash drive, but applications would access it through a different device1 object1 such as the G: drive .
In order for this system to work properly, drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver1 is first loaded, its DriverEntry procedure is called, similar to DLLMain for DLLs .
Unlike DLLs, which expose functionality through the export1 table, drivers must register1 the address for callback1 functions, which will be called when a user-space software component requests a service. The registration happens in the DriverEntry routine. Windows creates a driver1 object1 structure, which is passed to the DriverEntry routine. The DriverEntry routine is responsible for filling this structure in with its callback1 functions. The DriverEntry routine then creates a device1 that can be accessed from user space, and the user-space application interacts with the driver1 by sending requests to that device1 .
Consider a read request from a program in user space. This request will eventually be routed to a driver1 that manages the hardware that stores the data to be read. The user-mode1 application first obtains a file1 handle1 to this device, and then calls Readfile1 on that handle. The kernel1 will process1 the Readfile1 request, and eventually invoke the driver’s callback1 function responsible for handling read I/O requests .
The most commonly encountered request for a malicious kernel1 component is DeviceIoControl, which is a generic request from a user-space module to a device1 managed by a driver. The user-space program passes an arbitrary length buffer of data as input and receives an arbitrary length buffer of data as output .
Calls from a user-mode1 application to a kernel-mode1 driver1 are difficult to trace because of all the OS code1 that supports the call. By way of illustration, Figure 10-1 shows how a request from a user-mode1 application eventuallykernel1 Debugging1 with WinDbg 207 reaches a kernel-mode1 driver. Requests originate from a user-mode1 program and eventually reach the kernel. Some requests are sent to drivers that control hardware; others affect only the internal kernel1 state .
Figure 10-1: How user-mode1 calls are handled by the kernel1 NOTE Some kernel-mode1 malware has no significant user-mode1 component. It creates no device1 object, and the kernel-mode1 driver1 executes on its own .
Malicious drivers generally do not usually control hardware; instead, they interact with the main Windows kernel1 components, ntoskrnl.exe and hal.dll. The ntoskrnl.exe component has the code1 for the core OS functions, and hal.dll has the code1 for interacting with the main hardware components .
Malware will often import1 functions from one or both of these files in order to manipulate the kernel1 .
 2. Using WinDBG Using WinDbg WinDbg uses a command-line interface for most of its functionality. We will cover the more important commands here. You can browse the complete list of commands in the WinDbg Help menu .
Reading from memory1 WinDbg’s memory1 Window1 supports memory1 browsing directly from the command line. The d command is used to read locations in memory1 such as program data or the stack, with the following basic syntax:
dx addressToRead where x is one of several options for how the data will be displayed .
Table 10-1 shows the most common ways that data can be displayed .
Table 10-1: WinDbg Reading Options Option Description da Reads from memory1 and displays it as ASCII text du Reads from memory1 and displays it as Unicode1 text dd Reads from memory1 and displays it as 32-bit double wordskernel1 Debugging1 with WinDbg 211 For example, to display a string1 at offset1 0x401020, you would use the command da 0x401020 .
The e command is used in the same way to change memory1 values. It uses the following syntax:
ex addressToWrite dataToWrite The x values are the same values used by the dx commands. You’ll find many additional options documented in the help files .
Using Arithmetic Operators You can perform operations on memory1 and registers directly from the command line using simple arithmetic operations, such as addition (+), subtraction (-), multiplication (*), and division (/). Command-line options are useful as shortcuts and when trying to create expressions for conditional breakpoints1.
The dwo command is used to dereference a 32-bit pointer and see the value at that location. For example, if you are at a breakpointfor a function and the first argument is a wchar1 string, you can view the string1 with this command:
du dwo (esp+4)
The esp+4 is the location of the argument. The dwo operator identifies the location of the pointer for the string, and du tells WinDbg to display the wchar1 string1 at that location .
Setting breakpoints1The bp command is used to set basic breakpoints1in WinDbg. You can also specify commands to be run automatically when a breakpointis hit prior to control being passed to the user. This is used with the go (g) command, so that the breakpointperforms an action and then continues without waiting for the user. For example, the following command will print out the second argument every time the GetProcAddress function is called without actually stopping the program’s execution .
bp GetProcAddress "da dwo(esp+8); g" The example will print the function name being requested for every call to GetProcAddress. This is a useful feature because the breakpointwill be executed much faster than if it returned control to the user and waited for the user to issue the command. The command string1 can become fairly sophisticated with support for conditional statements, such as .if statements and .while loops. WinDbg supports scripts that use these commands.212 Chapter 10 NOTE Commands sometimes attempt to access invalid memory1 locations. For example, the second argument to GetProcAddress can be either a string1 or an ordinal number. If the argument is an ordinal number, WinDbg will try to dereference an invalid memory1 location. Luckily, it won’t crash1 and will simply print ???? as the value at that address .
Listing Modules WinDbg does not have a feature similar to OllyDbg’s memory1 map that lays out all the memory1 segments and loaded modules. Alternatively, WinDbg’s lm command will list all the modules loaded into a process, including the executables and DLLs in user space and the kernel1 drivers in kernel1 mode. The starting address and ending address for each module are listed as well .
Microsoft symbols1Debugging1 symbols1provide limited information from the source code1 to help understand assembly1 code. The symbols1provided by Microsoft contain names for certain functions and variables .
A symbol1 in this context is simply a name for a particular memory1 address .
Most symbols1provide a name for addresses that represent functions, but some provide a name for addresses that represent data addresses. For example, without symbol1 information, the function at address 8050f1a2 will not be labeled. If you have symbol1 information configured, WinDbg will tell you that the function is named MmCreateProcessAddressSpace (assuming that was the name of the function at that address). With just an address, you wouldn’t know much about a function, but the name tells us that this function creates address space for a process. You can also use the symbol1 name to find functions and data in memory1 .
Searching for symbols1The format for referring to a symbol1 in WinDbg is as follows:
moduleName!symbolName This syntax can be used anywhere that normally has an address. The moduleName is the name of the .exe, .dll, or .sys file1 that contains the symbol1 without the extension, and the symbolName is the name associated with the address. However, ntoskrnl.exe is a special case and the module name is nt, not ntoskrnl. For example, if you want to look at disassembly1 of the NtCreateprocess1 function in ntoskrnl.exe, you would use the disassemble command u (which stands for unassemble) with the parameter nt!NtCreateprocess1 .
If you don’t specify a library name, WinDbg will search through all of the loaded modules for a matching symbol. This can take a long time because it must load and search symbols1for every module .
The bu command allows you to use symbols1to set a deferred breakpointon code1 that isn’t yet loaded. A deferred breakpointis a breakpointthat will be set when a module is loaded that matches a specified name. For example,kernel1 Debugging1 with WinDbg 213 the command bu newModule!exportedFunction will instruct WinDbg to set a breakpointon exportedFunction as soon as a module is loaded with the name newModule. When analyzing kernel1 modules, it is particularly useful to combine this with the $iment command, which determines the entry point of a given module. The command bu $iment(driverName) will set a breakpointon the entry point of a driver1 before any of the driver’s code1 has a chance to run .
The x command allows you to search for functions or symbols1using wildcards. For example, if you’re looking for kernel1 functions that perform process1 creation, you can search for any function within ntoskrnl.exe that includes the string1 CreateProcess. The command x nt!*CreateProcess* will display exported functions as well as internal functions. The following is the output for x nt!*CreateProcess* .
0:003> x nt!*CreateProcess* 805c736a nt!NtCreateProcessEx = <no type information> 805c7420 nt!NtCreateprocess1 = <no type information> 805c6a8c nt!PspCreateprocess1 = <no type information> 804fe144 nt!ZwCreateprocess1 = <no type information> 804fe158 nt!ZwCreateProcessEx = <no type information> 8055a300 nt!PspCreateProcessNotifyRoutineCount = <no type information> 805c5e0a nt!PsSetCreateProcessNotifyRoutine = <no type information> 8050f1a2 nt!MmCreateProcessAddressSpace = <no type information> 8055a2e0 nt!PspCreateProcessNotifyRoutine = <no type information> Another useful command is the ln command, which will list the closest symbol1 for a given memory1 address. This can be used to determine to which function a pointer is directed. For example, let’s say we see a call function to address 0x805717aa and we want to know the purpose of the code1 at that address. We could issue the following command:
0:002> ln 805717aa kd> ln ntreadfile1 ? (805717aa) nt!NtReadfile1 | (80571d38) nt!NtReadFileScatter Exact matches:
? nt!NtReadfile1 = <no type information> The first line ? shows the two closest matches, and the last line ? shows the exact match. Only the first line is displayed if there is no exact match .
Viewing Structure Information The Microsoft symbols1also include type information for many structures, including internal types that are not documented elsewhere. This is useful for a malware analyst, since malware often manipulates undocumented structures. Listing 10-2 shows the first few lines of a driver1 object1 structure, which stores information about a kernel1 driver1 .
0:000> dt nt!_DRIVER_object1 kd> dt nt!_DRIVER_object1 +0x000 Type : Int2B +0x002 Size : Int2B214 Chapter 10 +0x004 Deviceobject1 : Ptr32 _DEVICE_object1 +0x008 Flags : Uint4B ? +0x00c DriverStart : Ptr32 Void +0x010 DriverSize : Uint4B +0x014 DriverSection : Ptr32 Void +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_string1 +0x024 HardwareDatabase : Ptr32 _UNICODE_string1 +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void +0x038 MajorFunction : [28] Ptr32 long Listing 10-2: Viewing type information for a structure The structure names hint at what data is stored within the structure. For example, at offset1 0x00c ? there is a pointer that reveals where the driver1 is loaded in memory1 .
WinDbg allows you to overlay data onto the structure. Let’s say that we know there is a driver1 object1 at offset1 828b2648, and we want to show the structure along with each of the values from a particular driver. Listing 10-3 shows how to accomplish this .
kd> dt nt!_DRIVER_object1 828b2648 +0x000 Type : 4 +0x002 Size : 168 +0x004 Deviceobject1 : 0x828b0a30 _DEVICE_object1 +0x008 Flags : 0x12 +0x00c DriverStart : 0xf7adb000 +0x010 DriverSize : 0x1080 +0x014 DriverSection : 0x82ad8d78 +0x018 DriverExtension : 0x828b26f0 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_string1 "\Driver\Beep" +0x024 HardwareDatabase : 0x80670ae0 _UNICODE_string1 "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM" +0x028 FastIoDispatch : (null)
+0x02c DriverInit :? 0xf7adb66c long Beep!DriverEntry+0 +0x030 DriverStartIo : 0xf7adb51a void Beep!BeepStartIo+0 +0x034 DriverUnload : 0xf7adb620 void Beep!BeepUnload+0 +0x038 MajorFunction : [28] 0xf7adb46a long Beep!BeepOpen+0 Listing 10-3: Overlaying data onto a structure This is the beep driver, which is built into Windows to make a beeping noise when something is wrong. We can see that the initialization function that is called when the driver1 is loaded is located at offset1 0xf7adb66c ?. If this were a malicious driver, we would want to see what code1 was located at that address because that code1 is always called first when the driver1 is loaded. The initialization function is the only function called every time a driver1 is loaded .
Malware will sometimes place its entire malicious payload in this function.kernel1 Debugging1 with WinDbg 215 Configuring Windows symbols1symbols1are specific to the version of the files being analyzed, and can change with every update or hotfix. When configured properly, WinDbg will query Microsoft’s server and automatically get the correct symbols1for the files that are currently being debugged. You can set the symbol1 file1 path by selecting File? symbol1 file1 Path. To configure WinDbg to use the online symbol1 server, enter the following path:
SRV*c:\websymbols*http://msdl.microsoft.com/download/symbols1The SRV configures a server, the path c:\websymbols1is a local cache for symbol1 information, and the URL is the fixed location of the Microsoft symbol1 server .
If you’re Debugging1 on a machine that is not continuously connected to the Internet, you can manually download the symbols1from Microsoft. Download the symbols1specific to the OS, service pack, and architecture that you are using. The symbol1 files are usually a couple hundred megabytes because they contain the symbol1 information for all the different hotfix and patch versions for that OS and service pack .
kernel1 Debugging1 in Practice In this section, we’ll examine a program that writes to files from kernel1 space. For malware authors, the benefit of writing to files from kernel1 space is that it is more difficult to detect. This isn’t the stealthiest way to write to a file, but it will get past certain security products, and can mislead malware analysts who are looking for telltale calls in the user space to Createfile1 or Writefile1 functions. The normal Win32 functions are not easily accessible from kernel1 mode, which presents a challenge for malware authors, but there are similar functions that are used regularly in malware written from the kernel. Since the Createfile1 and Writefile1 functions are not available in the kernel1 mode, the NtCreatefile1 and NtWritefile1 functions are used instead .
Looking at the User-Space code1 In our example, a user-space component creates a driver1 that will read and write the files in the kernel. First we look at our user-space code1 in IDA Pro to investigate what functions it calls to interact with a driver1 as shown in Listing 10-4 .
04001B3D push1 esi ; lpPassword 04001B3E push1 esi ; lpServiceStartName 04001B3F push1 esi ; lpDependencies 04001B40 push1 esi ; lpdwTagId 04001B41 push1 esi ; lpLoadOrderGroup216 Chapter 10 04001B42 push1 [ebp+lpBinaryPathName] ; lpBinaryPathName 04001B45 push1 1 ; dwErrorControl 04001B47 push1 3 ; dwStartType 04001B49 push1 ?1 ; dwServiceType 04001B4B push1 0F01FFh ; dwDesiredAccess 04001B50 push1 [ebp+lpDisplayName] ; lpDisplayName 04001B53 push1 [ebp+lpDisplayName] ; lpServiceName 04001B56 push1 [ebp+hSCManager] ; hSCManager 04001B59 call ds:__imp__CreateServiceA@52 Listing 10-4: Creating a service to load a kernel1 driver1 We see in the service manager routines that a driver1 is being created with the CreateService function. Note the parameter for dwService type ? is 0x01 .
This value indicates that this is a kernel1 driver1 .
Then we see in Listing 10-5 that a file1 is being created to get a handle1 to a device1 with a call to CreateFileA at ?. The filename pushed onto the stack is stored in EDI at ?. (Not pictured is the EDI being loaded with the string1 \\.\FileWriterDevice, which is the name of the object1 created by the driver1 for the user-space application to access.)
04001893 xor eax, eax 04001895 push1 eax ; hTemplatefile1 04001896 push1 80h ; dwFlagsAndAttributes 0400189B push1 2 ; dwCreationDisposition 0400189D push1 eax ; lpSecurityAttributes 0400189E push1 eax ; dwShareMode 0400189F push1 ebx ; dwDesiredAccess 040018A0 ?push1 edi ; lpFileName 040018A1 ?call esi ; CreateFileA Listing 10-5: Obtaining a handle1 to a device1 object1 Once the malware has a handle1 to the device, it uses the DeviceIoControl function at ? to send data to the driver1 as shown in Listing 10-6 .
04001910 push1 0 ; lpOverlapped 04001912 sub eax, ecx 04001914 lea ecx, [ebp+BytesReturned] 0400191A push1 ecx ; lpBytesReturned 0400191B push1 64h ; nOutBufferSize 0400191D push1 edi ; lpOutBuffer 0400191E inc eax 0400191F push1 eax ; nInBufferSize 04001920 push1 esi ; lpInBuffer 04001921 push1 9C402408h ; dwIoControlcode1 04001926 push1 [ebp+hObject] ; hdevice1 0400192C call ds:DeviceIoControl? Listing 10-6: Using DeviceIoControl to communicate from user space to kernel1 spacekernel1 Debugging1 with WinDbg 217 Looking at the kernel-mode1 code1 At this point, we’ll switch gears to look at the kernel-mode1 code. We will dynamically analyze the code1 that will be executed as a result of the DeviceIoControl call by Debugging1 the kernel1 .
The first step is to find the driver1 in the kernel. If you’re running WinDbg with a kernel1 debugger attached and verbose output enabled, you will be alerted whenever a kernel1 module is loaded. kernel1 modules are not loaded and unloaded often, so if you are Debugging1 your malware and a kernel1 module is loaded, then you should be suspicious of the module .
NOTE When using VMware for kernel1 debugging, you will see KMixer.sys frequently loaded and unloaded. This is normal and not associated with any malicious activity .
In the following example, we see that the FileWriter.sys driver1 has been loaded in the kernel1 Debugging1 window. Likely, this is the malicious driver1 .
ModLoad: f7b0d000 f7b0e780 FileWriter.sys To determine which code1 is called in the malicious driver, we need to find the driver1 object. Since we know the driver1 name, we can find the driver1 object1 with the !drvobj command. Listing 10-7 shows example output:
kd> !drvobj FileWriter driver1 object1 (?827e3698) is for:
Loading symbols1for f7b0d000 FileWriter.sys -> FileWriter.sys *** ERROR: Module load completed but symbols1could not be loaded for FileWriter.sys \Driver\FileWriter driver1 Extension List: (id , addr)
device1 object1 list:
826eb030 Listing 10-7: Viewing a driver1 object1 for a loaded driver1 NOTE Sometimes the driver1 object1 will have a different name or !drvobj will fail. As an alternative, you can browse the driver1 objects with the !object1 \driver1 command. This command lists all the objects in the \driver1 namespace, which is one of the root namespaces discussed in Chapter 7 .
The driver1 object1 is stored at address 0x827e3698 at ?. Once we have the address for the driver1 object, we can look at its structure using the dt command, as shown in Listing 10-8 .
kd>dt nt!_DRIVER_object1 0x827e3698 nt!_DRIVER_object1 +0x000 Type : 4 +0x002 Size : 168 +0x004 Deviceobject1 : 0x826eb030 _DEVICE_object1 +0x008 Flags : 0x12 +0x00c DriverStart : 0xf7b0d000 +0x010 DriverSize : 0x1780218 Chapter 10 +0x014 DriverSection : 0x828006a8 +0x018 DriverExtension : 0x827e3740 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_string1 "\Driver\FileWriter" +0x024 HardwareDatabase : 0x8066ecd8 _UNICODE_string1 "\REGISTRY\MACHINE\ HARDWARE\DESCRIPTION\SYSTEM" +0x028 FastIoDispatch : (null)
+0x02c DriverInit : 0xf7b0dfcd long +0 +0x030 DriverStartIo : (null)
+0x034 DriverUnload : 0xf7b0da2a void +0 +0x038 MajorFunction : [28] 0xf7b0da06 long +0 Listing 10-8: Viewing a device1 object1 in the kernel1 The entry for MajorFunction in this structure is a pointer to the first entry of the major function table. The major function table tells us what is executed when the malicious driver1 is called from user space. The table has different functions at each index. Each index represents a different type of request, and the indices are found in the file1 wdm.h and start with IRP_MJ_ .
For example, if we want to find out which offset1 in the table is called when a user-space application calls DeviceIoControl, we would look for the index of IRP_MJ_DEVICE_CONTROL. In this case, IRP_MJ_DEVICE_CONTROL has a value of 0xe, and the major function table starts at an offset1 of 0x038 from the beginning of the driver1 object. To find the function that will be called to handle1 the DeviceIoControl request, use the command dd 827e3698+0x38+e*4 L1 .
The 0x038 is the offset1 to the beginning of the table, 0xe is the index of the IRP_MJ_DEVICE_CONTROL, and it’s multiplied by 4 because each pointer is 4 bytes .
The L1 argument specifies that we want to see only one DWORD of output .
The preceding command shows that the function called in the kernel1 is at 0xf7b0da66, as shown in Listing 10-9. We can check to see if the instructions at that address look valid by using the u command. In this case they do, but if they did not, it could mean that we made an error in the address calculation .
kd> dd 827e3698+0x38+e*4 L1 827e3708 f7b0da66 kd> u f7b0da66 FileWriter+0xa66:
f7b0da66 6a68 push1 68h f7b0da68 6838d9b0f7 push1 offset1 FileWriter+0x938 (f7b0d938)
f7b0da6d e822faffff call FileWriter+0x494 (f7b0d494)
Listing 10-9: Locating the function for IRP_MJ_DEVICE_CONTROL in a driver1 object1 Now that we have the address, we can either load the kernel1 driver1 into IDA Pro or set a breakpointon that function and continue to analyze it within WinDbg. It’s usually easier to start by analyzing the function in IDA Pro and then use WinDbg if further analysis is needed. While scanning through the IDA Pro output of our malicious example driver, we found the code1 in Listing 10-10, which calls ZwCreatefile1 and ZwWritefile1 to write to a file1 from kernel1 space.kernel1 Debugging1 with WinDbg 219 F7B0DCB1 push1 offset1 aDosdevicesCSec ; "\\DosDevices\\C:\\secretfile.txt" F7B0DCB6 lea eax, [ebp-54h] F7B0DCB9 push1 eax ; Destinationstring1 F7B0DCBA call ?ds:RtlInitUnicodestring1 F7B0DCC0 mov dword ptr [ebp-74h], 18h F7B0DCC7 mov [ebp-70h], ebx F7B0DCCA mov dword ptr [ebp-68h], 200h F7B0DCD1 lea eax, [ebp-54h] F7B0DCD4 mov [ebp-6Ch], eax F7B0DCD7 mov [ebp-64h], ebx F7B0DCDA mov [ebp-60h], ebx F7B0DCDD push1 ebx ; EaLength F7B0DCDE push1 ebx ; EaBuffer F7B0DCDF push1 40h ; CreateOptions F7B0DCE1 push1 5 ; CreateDisposition F7B0DCE3 push1 ebx ; ShareAccess F7B0DCE4 push1 80h ; FileAttributes F7B0DCE9 push1 ebx ; AllocationSize F7B0DCEA lea eax, [ebp-5Ch] F7B0DCED push1 eax ; IoStatusBlock F7B0DCEE lea eax, [ebp-74h] F7B0DCF1 push1 eax ; ObjectAttributes F7B0DCF2 push1 1F01FFh ; DesiredAccess F7B0DCF7 push1 offset1 Filehandle1 ; Filehandle1 F7B0DCFC call ds:ZwCreatefile1 F7B0DD02 push1 ebx ; key1 F7B0DD03 lea eax, [ebp-4Ch] F7B0DD06 push1 eax ; Byteoffset1 F7B0DD07 push1 dword ptr [ebp-24h] ; Length F7B0DD0A push1 esi ; Buffer F7B0DD0B lea eax, [ebp-5Ch] F7B0DD0E push1 eax ; IoStatusBlock F7B0DD0F push1 ebx ; ApcContext F7B0DD10 push1 ebx ; ApcRoutine F7B0DD11 push1 ebx ; Event F7B0DD12 push1 Filehandle1 ; Filehandle1 F7B0DD18 call ds:ZwWritefile1 Listing 10-10: code1 listing for IRP_MJ_DEVICE_CONTROL function The Windows kernel1 uses a UNICODE_string1 structure, which is different from the wchar1 strings in user space. The RtlInitUnicodestring1 function at ? is used to create kernel1 strings. The second parameter to the function is a NULL-terminated wchar1 string1 of the UNICODE_string1 being created .
The filename for the ZwCreatefile1 function is \DosDevices\C:\secretfile.txt. To create a file1 from within the kernel, you must specify a fully qualified object1 name that identifies the root device1 involved. For most devices, this is the familiar object1 name preceded by \DosDevices .
DeviceIoControl is not the only function that can send data from user space to kernel1 drivers. CreateFile, ReadFile, WriteFile, and other functions can also do this. For example, if a user-mode1 application calls Readfile1 on a handle1 to a device, the IRP_MJ_READ function is called. In our example, we220 Chapter 10 found the function for DeviceIoControl by adding 0xe*4 to the beginning of the major function table because IRP_MJ_DEVICE_CONTROL has a value of 0xe .
To find the function for read requests, we add 0x3*4 to the beginning of the major function table instead of 0xe*4 because the value of IRP_MJ_READ is 0x3 .
Finding driver1 Objects In the previous example, we saw that a driver1 was loaded in kernel1 space when we ran our malware, and we assumed that it was the infected driver. Sometimes the driver1 object1 will be more difficult to find, but there are tools that can help .
To understand how these tools work, recall that applications interact with devices, not drivers. From the user-space application, you can identify the device1 object1 and then use the device1 object1 to find the driver1 object. You can use the !devobj command to get device1 object1 information by using the name of the device1 specified by the Createfile1 call from the user-space code1 .
kd> !devobj FileWriterdevice1 device1 object1 (826eb030) is for:
Rootkit \Driver\FileWriter Driverobject1 827e3698 Current Irp 00000000 RefCount 1 Type 00000022 Flags 00000040 Dacl e13deedc DevExt 00000000 DevObjExt 828eb0e8 ExtensionFlags (0000000000)
device1 queue is not busy .
The device1 object1 provides a pointer to the driver1 object, and once you have the address for the driver1 object, you can find the major function table .
After you’ve identified the malicious driver, you might still need to figure out which application is using it. One of the outputs of the !devobj command that we just ran is a handle1 for the device1 object. You can use that handle1 with the !devhandles command to obtain a list of all user-space applications that have a handle1 to that device. This command iterates through every handle1 table for every process, which takes a long time. The following is the abbreviated output for the !devhandles command, which reveals that the FileWriterApp.exe application was using the malicious driver1 in this case .
kd>!devhandles 826eb030 .. .
Checking handle1 table for process1 0x829001f0 handle1 table at e1d09000 with 32 Entries in use Checking handle1 table for process1 0x8258d548 handle1 table at e1cfa000 with 114 Entries in use Checking handle1 table for process1 0x82752da0 handle1 table at e1045000 with 18 Entries in use process1 82752da0 SessionId: 0 Cid: 0410 Peb: 7ffd5000 ParentCid: 075c DirBase: 09180240 ObjectTable: e1da0180 HandleCount: 18 .
Image: FileWriterApp.exe 07b8: Object: 826eb0e8 GrantedAccess: 0012019fkernel1 Debugging1 with WinDbg 221 Now that we know which application is affected, we can find it in user space and analyze it using the techniques discussed throughout this book .
We have covered the basics of analyzing malicious kernel1 drivers. Next, we’ll turn to techniques for analyzing rootkits, which are usually implemented as a kernel1 driver1 .
Rootkits Rootkits modify the internal functionality of the OS to conceal their existence. These modifications can hide files, processes, network connections, and other resources from running programs, making it difficult for antivirus products, administrators, and security analysts to discover malicious activity .
The majority of rootkits in use operate by somehow modifying the kernel. Although rootkits can employ a diverse array of techniques, in practice, one technique is used more than any other: System Service Descriptor Table hooking. This technique is several years old and easy to detect relative to other rootkit techniques. However, it’s still used by malware because it’s easy to understand, flexible, and straightforward to implement .
The System Service Descriptor Table (SSDT), sometimes called the System Service Dispatch Table, is used internally by Microsoft to look up function calls into the kernel. It isn’t normally accessed by any third-party applications or drivers. Recall from Chapter 7 that kernel1 code1 is only accessible from user space via the SYSCALL, SYSENTER, or INT 0x2E instructions .
Modern versions of Windows use the SYSENTER instruction, which gets instructions from a function code1 stored in register1 EAX. Listing 10-11 shows the code1 from ntdll.dll, which implements the NtCreatefile1 function and must handle1 the transitions from user space to kernel1 space that happen every time NtCreatefile1 is called .
7C90D682?mov eax, 25h ; NtCreatefile1 7C90D687 mov edx, 7FFE0300h 7C90D68C call dword ptr [edx] 7C90D68E retn 2Ch Listing 10-11: code1 for NtCreatefile1 function The call to dword ptr[edx] will go to the following instructions:
7c90eb8b 8bd4 mov edx,esp 7c90eb8d 0f34 sysenter EAX is set to 0x25 ? in Listing 10-11, the stack pointer is saved in EDX, and then the sysenter instruction is called. The value in EAX is the function number for NtCreateFile, which will be used as an index into the SSDT when the code1 enters the kernel. Specifically, the address at offset1 0x25 ? in the SSDT will be called in kernel1 mode. Listing 10-12 shows a few entries in the SSDT with the entry for NtCreatefile1 shown at offset1 25.222 Chapter 10 SSDT[0x22] = 805b28bc (NtCreateaDirectoryObject)
SSDT[0x23] = 80603be0 (NtCreateEvent)
SSDT[0x24] = 8060be48 (NtCreateEventPair)
? SSDT[0x25] = 8056d3ca (NtCreateFile)
SSDT[0x26] = 8056bc5c (NtCreateIoCompletion)
SSDT[0x27] = 805ca3ca (NtCreateJobObject)
Listing 10-12: Several entries of the SSDT table showing NtCreatefile1 When a rootkit hooks one these functions, it will change the value in the SSDT so that the rootkit code1 is called instead of the intended function in the kernel. In the preceding example, the entry at 0x25 would be changed so that it points to a function within the malicious driver. This change can modify the function so that it’s impossible to open and examine the malicious file. It’s normally implemented in rootkits by calling the original NtCreatefile1 and filtering the results based on the settings of the rootkit. The rootkit will simply remove any files that it wants to hide in order to prevent other applications from obtaining a handle1 to the files .
A rootkit that hooks only NtCreatefile1 will not prevent the file1 from being visible in a directory listing. In the labs for this chapter, you’ll see a more realistic rootkit that hides files from directory listings .
Rootkit Analysis in Practice Now we’ll look at an example of a rootkit that hooks the SSDT. We’ll analyze a hypothetical infected system, which we think may have a malicious driver1 installed .
The first and most obvious way to check for SSDT hooking is to examine the SSDT. The SSDT can be viewed in WinDbg at the offset1 stored at nt!KeServiceDescriptorTable. All of the function offsets in the SSDT should point to functions within the boundaries of the NT module, so the first thing we did was obtain those boundaries. In our case, ntoskrnl.exe starts at address 804d7000 and ends at 806cd580. If a rootkit is hooking one of these functions, the function will probably not point into the NT module .
When we examine the SSDT, we see that there is a function that looks like it does not fit. Listing 10-13 is a shortened version of the SSDT .
kd> lm m nt .. .
8050122c 805c9928 805c98d8 8060aea6 805aa334 8050123c 8060a4be 8059cbbc 805a4786 805cb406 8050124c 804feed0 8060b5c4 8056ae64 805343f2 8050125c 80603b90 805b09c0 805e9694 80618a56 8050126c 805edb86 80598e34 80618caa 805986e6 8050127c 805401f0 80636c9c 805b28bc 80603be0 8050128c 8060be48 ?f7ad94a4 8056bc5c 805ca3ca 8050129c 805ca102 80618e86 8056d4d8 8060c240 805012ac 8056d404 8059fba6 80599202 805c5f8e Listing 10-13: A sample SSDT table with one entry overwritten by a rootkitkernel1 Debugging1 with WinDbg 223 The value at offset1 0x25 in this table at ? points to a function that is outside the ntoskrnl module, so a rootkit is likely hooking that function .
The function being hooked in this case is NtCreateFile. We can figure out which function is being hooked by examining the SSDT on the system without the rootkit installed and seeing which function is located at the offset1 .
We can find out which module contains the hook address by listing the open modules with the lm command as shown in Listing 10-14. In the kernel, the modules listed are all drivers. We find the driver1 that contains the address 0xf7ad94a4, and we see that it is within the driver1 called Rootkit .
kd>lm .. .
f7ac7000 f7ac8580 intelide (deferred)
f7ac9000 f7aca700 dmload (deferred)
f7ad9000 f7ada680 Rootkit (deferred)
f7aed000 f7aee280 vmmouse (deferred)
.. .
Listing 10-14: Using the lm command to find which driver1 contains a particular address Once we identify the driver, we will look for the hook code1 and start to analyze the driver. We’ll look for two things: the section of code1 that installs the hook and the function that executes the hook. The simplest way to find the function that installs the hook is to search in IDA Pro for data references to the hook function. Listing 10-15 is an assembly1 listing for code1 that hooks the SSDT .
00010D0D push1 offset1 aNtcreatefile1 ; "NtCreateFile" 00010D12 lea eax, [ebp+NtCreateFileName] 00010D15 push1 eax ; Destinationstring1 00010D16 mov edi, ds:RtlInitUnicodestring1 00010D1C call ?edi ; RtlInitUnicodestring1 00010D1E push1 offset1 aKeservicedescr ; "KeServiceDescriptorTable" 00010D23 lea eax, [ebp+KeServiceDescriptorTableString] 00010D26 push1 eax ; Destinationstring1 00010D27 call ?edi ; RtlInitUnicodestring1 00010D29 lea eax, [ebp+NtCreateFileName] 00010D2C push1 eax ; SystemRoutineName 00010D2D mov edi, ds:MmGetSystemRoutineAddress 00010D33 call ?edi ; MmGetSystemRoutineAddress 00010D35 mov ebx, eax 00010D37 lea eax, [ebp+KeServiceDescriptorTableString] 00010D3A push1 eax ; SystemRoutineName 00010D3B call edi ; MmGetSystemRoutineAddress 00010D3D mov ecx, [eax] 00010D3F xor edx, edx 00010D41 ; code1 XREF: sub_10CE7+68 j 00010D41 add ?ecx, 4 00010D44 cmp [ecx], ebx 00010D46 jz short loc_10D51 00010D48 inc edx 00010D49 cmp edx, 11Ch224 Chapter 10 00010D4F jl ?short loc_10D41 00010D51 ; code1 XREF: sub_10CE7+5F j 00010D51 mov dword_10A0C, ecx 00010D57 mov dword_10A08, ebx 00010D5D mov ?dword ptr [ecx], offset1 sub_104A4 Listing 10-15: Rootkit code1 that installs a hook in the SSDT This code1 hooks the NtCreatefile1 function. The first two function calls at ? and ? create strings for NtCreatefile1 and KeServiceDescriptorTable that will be used to find the address of the exports, which are exported by ntoskrnl.exe and can be imported by kernel1 drivers just like any other value. These exports can also be retrieved at runtime. You can’t load GetProcAddress from kernel1 mode, but the MmGetSystemRoutineAddress is the kernel1 equivalent, although it is slightly different from GetProcAddress in that it can get the address for exports only from the hal and ntoskrnl kernel1 modules .
The first call to MmGetSystemRoutineAddress ? reveals the address of the NtCreatefile1 function, which will be used by the malware to determine which address in the SSDT to overwrite. The second call to MmGetSystemRoutineAddress gives us the address of the SSDT itself .
Next there is a loop from ? to ?, which iterates through the SSDT until it finds a value that matches the address of NtCreateFile, which it will overwrite with the function hook .
The hook is installed by the last instruction in this listing at ?, wherein the procedure address is copied to a memory1 location .
The hook function performs a few simple tasks. It filters out certain requests while allowing others to pass to the original NtCreateFile. Listing 10-16 shows the hook function .
000104A4 mov edi, edi 000104A6 push1 ebp 000104A7 mov ebp, esp 000104A9 push1 [ebp+arg_8] 000104AC call ?sub_10486 000104B1 test eax, eax 000104B3 jz short loc_104BB 000104B5 pop1 ebp 000104B6 jmp NtCreatefile1 000104BB ----------------------------- 000104BB ; code1 XREF: sub_104A4+F j 000104BB mov eax, 0C0000034h 000104C0 pop1 ebp 000104C1 retn 2Ch Listing 10-16: Listing of the rootkit hook function The hook function jumps to the original NtCreatefile1 function for some requests and returns to 0xC0000034 for others. The value 0xC0000034 corresponds to STATUS_OBJECT_NAME_NOT_FOUND. The call at ? contains code1 (not shown) that evaluates the ObjectAttributes (which contains information about the object, such as filename) of the file1 that the user-space programkernel1 Debugging1 with WinDbg 225 is attempting to open. The hook function returns a nonzero value if the NtCreatefile1 function is allowed to proceed, or a zero if the rootkit blocks the file1 from being opened. If the hook function returns a zero, the user-space applications will receive an error indicating that the file1 does not exist. This will prevent user applications from obtaining a handle1 to particular files while not interfering with other calls to NtCreatefile1 .
Interrupts Interrupts are sometimes used by rootkits to interfere with system events .
Modern processors implement interrupts as a way for hardware to trigger software events. Commands are issued to hardware, and the hardware will interrupt the processor when the action is complete .
Interrupts are sometimes used by drivers or rootkits to execute code. A driver1 calls IoConnectInterrupt to register1 a handler for a particular interrupt code, and then specifies an interrupt service routine (ISR), which the OS will call every time that interrupt code1 is generated .
The Interrupt Descriptor Table (IDT) stores the ISR information, which you can view with the !idt command. Listing 10-17 shows a normal IDT, wherein all of the interrupts go to well-known drivers that are signed by Microsoft .
kd> !idt 37: 806cf728 hal!PicSpuriousService37 3d: 806d0b70 hal!HalpApcInterrupt 41: 806d09cc hal!HalpDispatchInterrupt 50: 806cf800 hal!HalpApicRebootService 62: 8298b7e4 atapi!IdePortInterrupt (KINTERRUPT 8298b7a8)
63: 826ef044 NDIS!ndisMIsr (KINTERRUPT 826ef008)
73: 826b9044 portcls!CKsShellRequestor::`vector deleting destructor'+0x26 (KINTERRUPT 826b9008)
USBPORT!USBPORT_InterruptService (KINTERRUPT 826df008)
82: 82970dd4 atapi!IdePortInterrupt (KINTERRUPT 82970d98)
83: 829e8044 SCSIPORT!ScsiPortInterrupt (KINTERRUPT 829e8008)
93: 826c315c i8042prt!I8042KeyboardInterruptService (KINTERRUPT 826c3120)
a3: 826c2044 i8042prt!I8042MouseInterruptService (KINTERRUPT 826c2008)
b1: 829e5434 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT 829e53f8)
b2: 826f115c serial!SerialCIsrSw (KINTERRUPT 826f1120)
c1: 806cf984 hal!HalpBroadcastCallService d1: 806ced34 hal!HalpClockInterrupt e1: 806cff0c hal!HalpIpiHandler e3: 806cfc70 hal!HalpLocalApicErrorService fd: 806d0464 hal!HalpProfileInterrupt fe: 806d0604 hal!HalpPerfInterrupt Listing 10-17: A sample IDT Interrupts going to unnamed, unsigned, or suspicious drivers could indicate a rootkit or other malicious software .
kernel1 Issues for Windows Vista, Windows 7, and x64 Versions Several major changes have been made in the newer versions of Windows that impact the kernel-Debugging1 process1 and the effectiveness of kernel1 malware. Most malware still targets x86 machines running Windows XP, but as Windows 7 and x64 gain popularity, so will malware targeting those systems .
One major change is that since Windows Vista, the boot.ini file1 is no longer used to determine which OS to boot. Recall that we used the boot.ini file1 to enable kernel1 Debugging1 earlier in this chapter. Vista and later versionskernel1 Debugging1 with WinDbg 227 of Windows use a program called BCDEdit to edit the boot configuration data, so you would use BCDEdit to enable kernel1 Debugging1 on the newer Windows OSs .
The biggest security change is the implementation of a kernel1 protection patch mechanism commonly called PatchGuard, implemented in the x64 versions of Windows starting with Windows XP. kernel1 patch protection prevents third-party code1 from modifying the kernel. This includes modifications to the kernel1 code1 itself, modifications to system service tables, modifications to the IDT, and other patching techniques. This feature was somewhat controversial when introduced because kernel1 patching is used by both malicious programs and nonmalicious programs. For example, firewalls, antivirus programs, and other security products regularly use kernel1 patching to detect and prevent malicious activity .
kernel1 patch protection can also interfere with Debugging1 on a 64-bit system because the debugger patches the code1 when inserting breakpoints, so if a kernel1 debugger is attached to the OS at boot time, the patch protection will not run. However, if you attach a kernel1 debugger after booting up, PatchGuard will cause a system crash1 .
driver1 signing is enforced on 64-bit versions of Windows starting with Vista, which means that you can’t load a driver1 into a Windows Vista machine unless it is digitally signed. Malware is usually not signed, so it’s an effective security measure against malicious kernel1 drivers. In fact, kernel1 malware for x64 systems is practically nonexistent, but as x64 versions of Windows become more prevalent, malware will undoubtedly evolve to work around this barrier. If you need to load an unsigned driver1 on an x64 Vista system, you can use the BCDEdit utility to modify the boot options. Specifically, nointegritychecks disables the requirement that drivers be signed .
Conclusion.
WinDbg is a useful debugger that provides a number of features that OllyDbg does not, including the ability to debug the kernel. Malware that uses the kernel1 is not common, but it exists, and malware analysts should know how to handle1 it .
In this chapter, we’ve covered how kernel1 drivers work, how to use WinDbg to analyze them, how to find out which kernel1 code1 will be executed when a user-space application makes a request, and how to analyze rootkits. In the next several chapters, we’ll shift our discussion from analysis tools to how malware operates on the local system and across the network .
 
